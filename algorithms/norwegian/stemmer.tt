[% header('Persian stemming algorithm') %]

<h2>Introduction</h2>

<p>
This stemmer implements an <strong>HPS-like</strong> (Hierarchical Persian Stemmer) approach for Persian.
It removes common inflectional and derivational affixes across <em>noun</em>, <em>adjective</em>, and <em>verb</em> paradigms,
while aggressively normalizing Unicode to ensure stable matching. The design is
<strong>POS-tagger free</strong>, lightweight, and suitable for real-time use.
</p>

<h2>Normalization</h2>

<p>
All tokens are first normalized so downstream rules see a canonical form:
</p>
<ul>
  <li>Arabic variants are unified to Persian letters:
    <ul>
      <li>Arabic Kaf → Persian Kaf</li>
      <li>Arabic Yeh / Yeh-with-hamza → Persian Yeh</li>
      <li>Arabic Heh / Heh-marbuta → Persian Heh</li>
      <li>Arabic Alef-with-hamza (above/below) → Persian Alef</li>
      <li>Arabic Vav-with-hamza → Persian Vav</li>
    </ul>
  </li>
  <li>All separators are <em>deleted</em> (not replaced):
    <ul>
      <li>Zero-width non-joiner (ZWNJ / half-space)</li>
      <li>Zero-width joiner (ZWJ)</li>
      <li>ASCII space</li>
    </ul>
    The result is a single solid token for suffix/prefix matching.
  </li>
</ul>

<h2>Pipeline</h2>

<p>After normalization, the algorithm proceeds in fixed HPS-like stages:</p>

<ol>
  <li><strong>Strip start-anchored prefixes (forward)</strong> — At most one per pass, anchored at the token start.
      Recognizes <code>نمیـ</code>, <code>میـ</code>, <code>نا</code>, <code>بی</code>. When <code>میـ/نمیـ</code> is removed,
      a pass-local flag <code>saw_present_prefix</code> is set to allow verb person-ending rules.</li>

  <li><strong>Probe lexical <code>-ان</code></strong> — A backward probe sets <code>protect_lex_an</code> for
      stems where final <code>-ان</code> is lexical (e.g., <em>ایران، تهران، انسان، …ستان</em>), so plural stripping
      of <code>-ان</code> is suppressed in the current pass.</li>

  <li><strong>Peel exactly one suffix layer per pass (backward)</strong> — Apply tiers in this order:
    <ul>
      <li><strong>Noun</strong>: irregular rewrites, derivational endings (e.g. <code>-گاه، -دان</code>),
          plural markers (<code>-ها، -های، -ان، -ین</code>), and possessive clitics
          (<code>-م، -ت، -ش، -مان، -تان، -شان</code>). Any noun success sets <code>freeze_pass</code>,
          which short-circuits adjective/verb rules in the same pass.</li>
      <li><strong>Adjective</strong>: comparative/superlative (<code>-تر، -ترین</code>), common derivational endings
          (<code>-انه، -مند، -ناک، -وار/-گار</code>), and relative/final-<code>ی</code> cleanup.</li>
      <li><strong>Verb</strong>:
        <ul>
          <li><em>Participle + clitic tails</em> (e.g., <code>خورده‌ایم</code>, <code>نوشته‌است</code>) are removed in one step.</li>
          <li>Irregular rewrites (compact verb hash).</li>
          <li>Person/number endings (e.g., <code>-م، -ی، -د، -یم، -ید، -ند</code>), gated by either a present-prefix
              in this pass or an infinitive/participle cue.</li>
          <li>Tense/mood markers: infinitive <code>-ن/-ان</code>, participle <code>-ه</code> (sets <code>saw_inf_or_part</code>).</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>
The suffix layer step repeats until no rule fires, ensuring deeper reductions
occur gradually without skipping morphological layers.
</p>

<h2>Key Flags & Control Flow</h2>

<ul>
  <li><code>changed</code> — Set when a rule modifies the token in the current pass.</li>
  <li><code>protect_lex_an</code> — Guards lexical <code>-ان</code> from plural stripping in the current pass.</li>
  <li><code>freeze_pass</code> — Set by a noun success to skip adjective/verb tiers for this pass.</li>
  <li><code>saw_present_prefix</code> — Set when <code>میـ/نمیـ</code> is stripped; enables verb person endings.</li>
  <li><code>saw_inf_or_part</code> — Set when infinitive <code>-ن/-ان</code> or participle <code>-ه</code> is stripped; also enables person endings.</li>
</ul>

<h2>Differences from Original HPS</h2>

<ul>
  <li><strong>No POS-tagger dependency</strong>: fixed order (Noun → Adjective → Verb) for portability.</li>
  <li><strong>Lexical <code>-ان</code> protection</strong>: probe + curated hash (e.g., <em>ایران، تهران، انسان، …ستان</em>)
      to prevent over-stemming of place names/lexical stems.</li>
  <li><strong>Aggressive Unicode cleanup</strong>: ZWNJ, ZWJ, and ASCII spaces are deleted (not replaced).</li>
  <li><strong>Participle + clitic handling</strong>: dedicated stage removes tails like <code>خورده‌ایم</code>, <code>نوشته‌اید</code> in one go.</li>
  <li><strong>One-affix-per-pass</strong>: safer loop behavior and more interpretable reductions.</li>
  <li><strong>Conservative affix sets + length guards</strong>: reduce false positives in real-world text.</li>
</ul>

<h2>Limitations & Future Work</h2>

<ul>
  <li>Heuristic by design; a morph analyzer or POS tagger could further reduce edge-case errors.</li>
  <li>Domain-specific affixes and irregulars can be added as needed.</li>
</ul>

<h2>The full algorithm in Snowball</h2>

[% highlight_file('persian') %]

[% footer %]
